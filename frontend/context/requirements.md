## main components to implement

- authentication
- content search
- pages
- authorization
- feedback

## legacy - app.py functionality

- User Authentication: Registration (`/register`, `/api/register`), Login (`/login`, `/api/login`), Logout (`/api/logout`).

- Content Searching: A main page (`/`) that allows searching content via a query (`q`) and optionally language (`language`), interacting with `/api/search`.
- Static Pages: An "About" page (`/about`).
- User State: The application knows if a user is logged in (`g.user`) and adjusts behavior (e.g., redirects from `/login` if already logged in).
- Feedback: It uses flash messages for feedback (e.g., "You were logged in", "Invalid username").

## modern - Actix Web functionality

### architecture 
*   **Technology:** Rust with the Actix Web framework.
*   **Role:** Serves static web content (HTML, CSS, JS) and handles API requests previously managed by the separate Nginx/Backend combination. It will interact with the backend service for data operations.
   

### local development
- [local dev setup - in-depth](#local-dev-setup)

**setup in frontend/**
- .env.local.frontend
  - `FRONTEND_INTERNAL_PORT=x` // fx 8080
  - `BACKEND_INTERNAL_PORT=y`  // fx 8081
  - (opt) `DB_INTERNAL_PORT=z` // fx 3306
- cmds for run: 
  - Makefile.toml
    - `cargo make dev`         // cargo run with watch
    - `cargo make dev-docker`  // docker build && run 

#### necessary steps
```Bash
cp .env.local.frontend.template .env.local.frontend
# customize if needed
```
then ready to go:
```Bash
   cargo make dev
```
```Bash
   cargo make dev-docker
```




### deployment - env variables
*   **Orchestration & Configuration Flow:**
    1.  A `.env` file (typically generated by deployment workflows) defines environment variables: 
    - `COMPOSE_PROJECT_NAME`, 
    - `FRONTEND_INTERNAL_PORT`, 
    - and `BACKEND_INTERNAL_PORT`.
    2.  `docker-compose.dev.yml` reads these variables from `.env`.
    3.  The `frontend` service within `docker-compose.dev.yml` is defined:
        *   It uses the new Actix `Dockerfile` (located at the root or specified path) to build the frontend image.
        *   It passes necessary environment variables (`COMPOSE_PROJECT_NAME`, `FRONTEND_INTERNAL_PORT`, `BACKEND_INTERNAL_PORT`) into the running container.
        *   It maps the host port to the container's `FRONTEND_INTERNAL_PORT`.
        *   It connects the container to the `app-network` to communicate with the `backend` service.
    4.  The Actix application inside the container reads these environment variables at runtime to:
        *   Configure the port it listens on (`FRONTEND_INTERNAL_PORT`).
        *   Determine the address/port of the backend service it needs to call (`backend:${BACKEND_INTERNAL_PORT}`).












## in depth 

### local dev setup

Local Development Setup:

- Environment Variables: Local development relies on a dedicated .env.local.frontend file located at the project root (or a specified path like frontend/.env.local.frontend). This file should contain necessary variables like FRONTEND_INTERNAL_PORT and BACKEND_INTERNAL_PORT with values suitable for local testing (e.g., FRONTEND_INTERNAL_PORT=8080, BACKEND_INTERNAL_PORT=9000). This file should be added to .gitignore.
- Running with cargo: The cargo make dev task (or similar) should be configured to load variables from .env.local.frontend before running cargo watch or cargo run. This can be achieved using a tool like dotenv-cli.
- Running with docker: The cargo make dev-docker task (or similar) should use the --env-file frontend/.env.local.frontend flag during the docker run command to inject the local environment variables into the container.
