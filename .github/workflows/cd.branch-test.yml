# cd.branch-test.yml
name: branch-test - Continuous Deployment

on:
  push:
    branches: [python-to-rust] # <-- adjust for current branch to test
  workflow_dispatch:

env:
  # ---------------------------------------------
  # ------------ Environment Variables ----------
  #
  GHCR_REGISTRY: ghcr.io
  IMAGE_BASENAME: ${{ github.repository_owner }}/${{ github.event.repository.name }}
  # Secrets:
  GHCR_PAT_OR_TOKEN: ${{ secrets.DEV_GHCR_PAT_OR_TOKEN }}
  SERVER_USER: ${{ secrets.DEV_SERVER_USER }} # deployer
  SERVER_HOST: ${{ secrets.DEV_SERVER_HOST }} # IP or domain
  SERVER_PORT: ${{ secrets.DEV_SERVER_PORT }} # 22 ssh port, 10222
  # SSH:
  SSH_PRIVATE_KEY: ${{ secrets.DEV_SSH_PRIVATE_KEY }} # private key for SSH access
  ENV_FILE_CONTENT: ${{ secrets.DEV_ENV_FILE }} # .env file loaded content
  # Commands:
  SSH_CMD: ssh -i ~/.ssh/id_rsa -p ${{ secrets.DEV_SERVER_PORT }} -o StrictHostKeyChecking=no ${{ secrets.DEV_SERVER_USER }}@${{ secrets.DEV_SERVER_HOST }}
  SCP_CMD: scp -i ~/.ssh/id_rsa -P ${{ secrets.DEV_SERVER_PORT }} -o StrictHostKeyChecking=no
  # paths:
  ENV_FILE: .env.development # production or development
  DEPLOY_DIR: ./deployment/whoknows
  FRONTEND_PATH: ./frontend
  NGINX_FILE_PATH: ./frontend/nginx.conf
  BACKEND_PATH: ./backend
  DOCKER_COMPOSE_FILE: ./docker-compose.dev.yml # prod or dev
  DEPLOY_SCRIPT: ./deployment/scripts/deploy.sh
  DOCKER_LOGIN_SCRIPT: ./deployment/scripts/docker-login.sh

jobs:
  validate-config:
    uses: ./.github/workflows/validate.env_and_secrets.yml
    secrets:
      PROD_ENV_FILE: ${{ secrets.PROD_ENV_FILE }}
      DEV_ENV_FILE: ${{ secrets.DEV_ENV_FILE }}
      PROD_SSH_PRIVATE_KEY: ${{ secrets.PROD_SSH_PRIVATE_KEY }}
      DEV_SSH_PRIVATE_KEY: ${{ secrets.DEV_SSH_PRIVATE_KEY }}
      PROD_GHCR_PAT_OR_TOKEN: ${{ secrets.PROD_GHCR_PAT_OR_TOKEN }}
      DEV_GHCR_PAT_OR_TOKEN: ${{ secrets.DEV_GHCR_PAT_OR_TOKEN }}

  #
  # ---------------------------------------------
  # ----------------- build-push ----------------
  #
  build-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read # permission to read the repository contents
      packages: write # permission to write to the GitHub Container Registry (GHCR)
    outputs:
      backend_image_sha: ${{ env.GHCR_REGISTRY }}/${{ steps.lowercaser.outputs.image_base }}/backend:${{ steps.image_tags.outputs.tag_sha }} # backend container image sha tag
      frontend_image_sha: ${{ env.GHCR_REGISTRY }}/${{ steps.lowercaser.outputs.image_base }}/frontend:${{ steps.image_tags.outputs.tag_sha }} # frontend container image sha tag

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GHCR_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ env.GHCR_PAT_OR_TOKEN }}

      # --------------------------------------------
      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ env.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -p ${{ env.SERVER_PORT }} -H ${{ env.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Install dos2unix
        run: sudo apt-get update && sudo apt-get install -y dos2unix

      #-------------------- Debug: Check Remote Path --------------------
      #- name: Verify remote file existence and permissions via SSH
      #run: |
      #echo "Attempting to SSH into ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} on port ${{ env.SERVER_PORT }}"
      # Ensure SSH key is set up correctly first (assuming a previous step does this)
      # Example: Ensure correct permissions if you manually placed the key
      # mkdir -p ~/.ssh
      # echo "${{ env.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
      # chmod 600 ~/.ssh/id_rsa
      # ssh-keyscan -p ${{ env.SERVER_PORT }} ${{ env.SERVER_HOST }} >> ~/.ssh/known_hosts # Add host key if needed
      #ssh -i ~/.ssh/id_rsa -p ${{ env.SERVER_PORT }} -o StrictHostKeyChecking=no ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} 'ls -la /home/deployer/deployment/rust-actix-web_cd/'
      #ssh -i ~/.ssh/id_rsa -p ${{ env.SERVER_PORT }} -o StrictHostKeyChecking=no ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} 'ls -la /home/deployer/deployment/'
      #ssh -i ~/.ssh/id_rsa -p ${{ env.SERVER_PORT }} -o StrictHostKeyChecking=no ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} 'ls -la /home/deployer/'
      #ssh -i ~/.ssh/id_rsa -p ${{ env.SERVER_PORT }} -o StrictHostKeyChecking=no ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} 'pwd' # Confirm starting directory if path were relative

      - name: Debug remote file visibility # Renamed for focus
        run: |
          echo "--- Debugging remote file visibility ---"
          CURRENT_USER="${{ env.SERVER_USER }}"
          echo "Workflow SERVER_USER is: $CURRENT_USER"

          REMOTE_TARGET_DIR="/home/${CURRENT_USER}/deployment/rust-actix-web_cd"
          REMOTE_DB_FILE="${REMOTE_TARGET_DIR}/whoknows.db"
          REMOTE_OTHER_FILE="${REMOTE_TARGET_DIR}/nginx.conf" # Use another file we know exists

          echo "Target directory: $REMOTE_TARGET_DIR"
          echo "Target DB file: $REMOTE_DB_FILE"
          echo "Target Other file: $REMOTE_OTHER_FILE"

          SSH_FLAGS="-i ~/.ssh/id_rsa -p ${{ env.SERVER_PORT }} -o StrictHostKeyChecking=no -o ConnectTimeout=15"

          echo "--- Checking directory listing ---"
          ssh $SSH_FLAGS ${CURRENT_USER}@${{ env.SERVER_HOST }} "ls -la ${REMOTE_TARGET_DIR}/" || echo "!! Failed to list target directory contents !!"

          echo "--- Checking DB file with 'test -f' ---"
          # Use 'test -f' which is a basic existence check, exit code 0 means success (exists)
          ssh $SSH_FLAGS ${CURRENT_USER}@${{ env.SERVER_HOST }} "test -f ${REMOTE_DB_FILE}"
          if [ $? -eq 0 ]; then
              echo "✅ 'test -f' SUCCEEDED for DB file."
          else
              echo "❌ 'test -f' FAILED for DB file (exit code $?). It likely does not exist or isn't accessible."
          fi

          echo "--- Checking other file (nginx.conf) with 'test -f' ---"
          ssh $SSH_FLAGS ${CURRENT_USER}@${{ env.SERVER_HOST }} "test -f ${REMOTE_OTHER_FILE}"
          if [ $? -eq 0 ]; then
              echo "✅ 'test -f' SUCCEEDED for other file (nginx.conf)."
          else
              echo "❌ 'test -f' FAILED for other file (nginx.conf) (exit code $?)."
          fi

          echo "--- Checking DB file with 'ls -la' again ---"
          ssh $SSH_FLAGS ${CURRENT_USER}@${{ env.SERVER_HOST }} "ls -la ${REMOTE_DB_FILE}" || echo "!! 'ls -la' check FAILED for DB file !!"

          echo "--- Checking other file (nginx.conf) with 'ls -la' ---"
          ssh $SSH_FLAGS ${CURRENT_USER}@${{ env.SERVER_HOST }} "ls -la ${REMOTE_OTHER_FILE}" || echo "!! 'ls -la' check FAILED for other file !!"

          # Attempt SCP only if 'test -f' succeeded for the DB file - makes the failure clearer
          echo "--- Conditional SCP Attempt ---"
          ssh $SSH_FLAGS ${CURRENT_USER}@${{ env.SERVER_HOST }} "test -f ${REMOTE_DB_FILE}"
          if [ $? -eq 0 ]; then
              echo "File seems to exist via 'test -f', attempting SCP..."
              LOCAL_DATA_DIR="${{ env.BACKEND_PATH }}/data"
              mkdir -p "$LOCAL_DATA_DIR"
              SCP_FLAGS="-v -i ~/.ssh/id_rsa -P ${{ env.SERVER_PORT }} -o StrictHostKeyChecking=no -o ConnectTimeout=15"
              scp ${SCP_FLAGS} ${CURRENT_USER}@${{ env.SERVER_HOST }}:${REMOTE_DB_FILE} "${LOCAL_DATA_DIR}/"
              echo "Local dir contents after SCP:"
              ls -la "$LOCAL_DATA_DIR/"
          else
              echo "Skipping SCP because 'test -f' failed for DB file."
              # Force an error exit code since the required file seems missing
              exit 1
          fi

      - name: Setup deployment environment and copy DB
        run: |
          echo "--- Setting up deployment environment ---"
          # Explicitly check the user variable expansion
          CURRENT_USER="${{ env.SERVER_USER }}"
          echo "Workflow SERVER_USER is: $CURRENT_USER"
          if [ "$CURRENT_USER" != "deployer" ]; then
            echo "WARNING: SERVER_USER ($CURRENT_USER) might not match expected 'deployer'!"
          fi

          # Define local and remote paths
          LOCAL_DATA_DIR="${{ env.BACKEND_PATH }}/data" # Use workflow variable for local path base
          REMOTE_DB_PATH="/home/${CURRENT_USER}/deployment/rust-actix-web_cd/whoknows.db"
          REMOTE_DEPLOY_DIR="${{ env.DEPLOY_DIR }}" # Use workflow variable for deployment dir

          echo "Local data directory target: $LOCAL_DATA_DIR"
          echo "Remote DB path target: $REMOTE_DB_PATH"
          echo "Remote deploy directory target: $REMOTE_DEPLOY_DIR"

          # Create required local directory
          echo "Creating local directory: $LOCAL_DATA_DIR"
          mkdir -p "$LOCAL_DATA_DIR"

          # Define SSH flags directly for debugging
          SSH_FLAGS="-i ~/.ssh/id_rsa -p ${{ env.SERVER_PORT }} -o StrictHostKeyChecking=no -o ConnectTimeout=15"
          SCP_FLAGS="-v -i ~/.ssh/id_rsa -P ${{ env.SERVER_PORT }} -o StrictHostKeyChecking=no -o ConnectTimeout=15" # Added -v

          # Ensure remote *deployment* directory exists (using DEPLOY_DIR variable)
          echo "Ensuring remote deployment target directory exists: $REMOTE_DEPLOY_DIR"
          ssh $SSH_FLAGS ${CURRENT_USER}@${{ env.SERVER_HOST }} "mkdir -p ${REMOTE_DEPLOY_DIR}"

          # --- DEBUG: Check remote file *immediately* before SCP ---
          echo "Verifying remote DB file existence and permissions RIGHT BEFORE SCP..."
          ssh $SSH_FLAGS ${CURRENT_USER}@${{ env.SERVER_HOST }} "ls -la ${REMOTE_DB_PATH}" || echo "!! Failed to list specific DB file right before SCP !!"
          echo "--- Finished immediate pre-SCP check ---"

          # Construct the exact SCP command string for logging
          SCP_COMMAND="scp ${SCP_FLAGS} ${CURRENT_USER}@${{ env.SERVER_HOST }}:${REMOTE_DB_PATH} \"${LOCAL_DATA_DIR}/\""
          echo "Executing SCP command: ${SCP_COMMAND}"

          # Attempt to Copy database using direct flags and verbose output
          scp ${SCP_FLAGS} ${CURRENT_USER}@${{ env.SERVER_HOST }}:${REMOTE_DB_PATH} "${LOCAL_DATA_DIR}/"

          # Verify file was copied locally
          echo "Contents of local directory $LOCAL_DATA_DIR after SCP attempt:"
          ls -la "$LOCAL_DATA_DIR/"

      - name: Setup deployment environment and copy DB # Renamed for clarity
        run: |
          echo "--- Setting up deployment environment ---"
          LOCAL_DATA_DIR="${{ env.BACKEND_PATH }}/data" # Use workflow variable for local path base
          REMOTE_DB_PATH="/home/${{ env.SERVER_USER }}/deployment/rust-actix-web_cd/whoknows.db"
          REMOTE_DB_DIR=$(dirname "$REMOTE_DB_PATH") # Get the remote directory path

          # Create required local directories
          echo "Creating local directory: $LOCAL_DATA_DIR"
          # Use workflow variable BACKEND_PATH consistently for local context
          mkdir -p "$LOCAL_DATA_DIR"

          # Define consistent SSH/SCP options
          # Added ConnectTimeout for robustness
          SSH_OPTS="-i ~/.ssh/id_rsa -p ${{ env.SERVER_PORT }} -o StrictHostKeyChecking=no -o ConnectTimeout=15"
          SCP_OPTS="-i ~/.ssh/id_rsa -P ${{ env.SERVER_PORT }} -o StrictHostKeyChecking=no -o ConnectTimeout=15"

          # --- DEBUG: Check remote path and permissions via SSH ---
          echo "Verifying remote path components for user ${{ env.SERVER_USER }}..."
          ssh $SSH_OPTS ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "ls -ld /home/${{ env.SERVER_USER }}/" || echo "Failed to list user home dir permissions"
          ssh $SSH_OPTS ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "ls -ld /home/${{ env.SERVER_USER }}/deployment/" || echo "Failed to list deployment dir permissions"
          ssh $SSH_OPTS ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "ls -ld ${REMOTE_DB_DIR}/" || echo "Failed to list DB directory permissions"
          ssh $SSH_OPTS ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "ls -la ${REMOTE_DB_PATH}" || echo "Failed to list specific DB file"
          echo "--- Finished remote path verification ---"

          # Ensure remote *deployment* directory exists (for later deployment steps)
          # This uses the DEPLOY_DIR variable relative path correctly
          echo "Ensuring remote deployment target directory exists: ${{ env.DEPLOY_DIR }}"
          ssh $SSH_OPTS ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "mkdir -p ${{ env.DEPLOY_DIR }}"

          # Attempt to Copy database from remote server to local build context
          echo "Attempting to copy DB from ${REMOTE_DB_PATH} to $LOCAL_DATA_DIR"
          # Added -v for verbose SCP output
          scp -v $SCP_OPTS ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${REMOTE_DB_PATH} "${LOCAL_DATA_DIR}/"

          # Verify file was copied locally
          echo "Contents of local directory $LOCAL_DATA_DIR after SCP attempt:"
          ls -la "$LOCAL_DATA_DIR/"

      - name: Setup deployment environment
        run: |
          # Create required local directories
          mkdir -p /home/runner/work/whoknows/whoknows/data

          # Use consistent SSH/SCP options for all connections
          SSH_OPTS="-i ~/.ssh/id_rsa -p ${{ env.SERVER_PORT }} -o StrictHostKeyChecking=no"
          SCP_OPTS="-i ~/.ssh/id_rsa -P ${{ env.SERVER_PORT }} -o StrictHostKeyChecking=no"

          # Ensure remote directory exists
          ssh $SSH_OPTS ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "mkdir -p ${{ env.DEPLOY_DIR }}"

          # Copy database from remote server to local build context
          scp -v $SCP_OPTS ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:/home/${{ env.SERVER_USER }}/deployment/rust-actix-web_cd/whoknows.db /home/runner/work/whoknows/whoknows/data/

          # Verify file was copied
          ls -la /home/runner/work/whoknows/whoknows/data/

      - name: debug 2
        run: |
          # mkdir
          ${{ env.SSH_CMD }} "mkdir -p ${{ env.DEPLOY_DIR }}" 

          # scp directly to final names
          ${{ env.SCP_CMD }} ${{ env.DOCKER_COMPOSE_FILE }} ${SERVER_DEST_BASE}/docker-compose.yml

          ${{ env.SSH_CMD }} "ls -l /home/deployer/deployment/rust-actix-web_cd"

          ${{ env.SCP_CMD }} ${{ env.DOCKER_LOGIN_SCRIPT }} ${SERVER_DEST_BASE}/docker-login.sh

      - name: debug - mkdir
        run: mkdir -p /home/runner/work/whoknows/whoknows/data

      #-------------------- Database Transfer --------------------
      - name: Copy whoknows.db from deploy server
        run: |

          ls /home/runner/work/whoknows/whoknows/
          mkdir -p /home/runner/work/whoknows/whoknows/data  # Create data directory in the build context
          ls /home/runner/work/whoknows/whoknows/
          scp -i ~/.ssh/id_rsa -P ${{ env.SERVER_PORT }} ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:/home/deployer/deployment/rust-actix-web_cd/whoknows.db /home/runner/work/whoknows/whoknows/data
          ls ${{ env.BACKEND_PATH }}/data

        # ---------------------------------------------

      - name: Lowercase Image Base Name
        id: lowercaser
        run: echo "image_base=$(echo ${{ env.IMAGE_BASENAME }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Define Image Tags
        id: image_tags
        run: |
          TAG_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          echo "tag_sha=${TAG_SHA}" >> $GITHUB_OUTPUT
          echo "tag_latest=latest" >> $GITHUB_OUTPUT

        # ---------------------------------------------

      - name: Build and Push Backend Image
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.BACKEND_PATH }}
          file: ${{ env.BACKEND_PATH }}/Dockerfile
          push: true # push true to push the image to the registry
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ steps.lowercaser.outputs.image_base }}/backend:${{ steps.image_tags.outputs.tag_latest }}
            ${{ env.GHCR_REGISTRY }}/${{ steps.lowercaser.outputs.image_base }}/backend:${{ steps.image_tags.outputs.tag_sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and Push Frontend Image
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.FRONTEND_PATH }}
          file: ${{ env.FRONTEND_PATH }}/Dockerfile
          push: true
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ steps.lowercaser.outputs.image_base }}/frontend:${{ steps.image_tags.outputs.tag_latest }}
            ${{ env.GHCR_REGISTRY }}/${{ steps.lowercaser.outputs.image_base }}/frontend:${{ steps.image_tags.outputs.tag_sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ---------------------------------------------
  # ----------------- deploy --------------------

  deploy:
    name: Deploy to Server
    needs: build-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ env.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -p ${{ env.SERVER_PORT }} -H ${{ env.SERVER_HOST }} >> ~/.ssh/known_hosts

        # ------------------------------------------

      - name: Install dos2unix
        run: sudo apt-get update && sudo apt-get install -y dos2unix

      - name: Create .env file
        run: |
          echo "${{ env.ENV_FILE_CONTENT }}" > ${{ env.ENV_FILE }}

          dos2unix ${{ env.ENV_FILE }}

          # Add image tags to .env file
          echo "IMAGE_TAG_BACKEND=${{ needs.build-push.outputs.backend_image_sha }}" >> ${{ env.ENV_FILE }}
          echo "IMAGE_TAG_FRONTEND=${{ needs.build-push.outputs.frontend_image_sha }}" >> ${{ env.ENV_FILE }}

        # ------------------------------------------

      # create/update VERSION file
      - name: updating VERSION file
        run: |
          SERVER_DEST_BASE="${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.DEPLOY_DIR }}"

          echo "DEPLOYMENT_TIME=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" > VERSION
          echo "GIT_COMMIT=${{ github.sha }}" >> VERSION
          echo "GIT_BRANCH=${GITHUB_REF#refs/heads/}" >> VERSION
          echo "IMAGE_TAG_BACKEND=${{ needs.build-push.outputs.backend_image_sha }}" >> VERSION
          echo "IMAGE_TAG_FRONTEND=${{ needs.build-push.outputs.frontend_image_sha }}" >> VERSION

          # Transfer to server
          ${{ env.SCP_CMD }} VERSION ${SERVER_DEST_BASE}/VERSION

        # ------------------------------------------

      - name: Transfer files to server
        run: |
          SERVER_DEST_BASE="${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.DEPLOY_DIR }}"

          # mkdir
          ${{ env.SSH_CMD }} "mkdir -p ${{ env.DEPLOY_DIR }}" 

          # scp directly to final names
          ${{ env.SCP_CMD }} ${{ env.DOCKER_COMPOSE_FILE }} ${SERVER_DEST_BASE}/docker-compose.yml
          ${{ env.SCP_CMD }} ${{ env.ENV_FILE }} ${SERVER_DEST_BASE}/.env
          ${{ env.SCP_CMD }} ${{ env.NGINX_FILE_PATH }} ${SERVER_DEST_BASE}/nginx.conf
          ${{ env.SCP_CMD }} ${{ env.DEPLOY_SCRIPT }} ${SERVER_DEST_BASE}/deploy.sh
          ${{ env.SCP_CMD }} ${{ env.DOCKER_LOGIN_SCRIPT }} ${SERVER_DEST_BASE}/docker-login.sh

              # dir: 
                # ~/deployment/whoknows/
                  # ├── docker-compose.yml
                  # ├── .env
                  # ├── VERSION
                  # ├── deploy.sh
                  # ├── docker-login.sh
                  # └── nginx.conf

        # ------------------------------------------

      - name: Execute Deployment on Server
        run: |
          DEPLOY_DIR="${{ env.DEPLOY_DIR }}"
          ENV_FILE="${{ env.ENV_FILE }}"
          DOCKER_COMPOSE_FILE="${{ env.DOCKER_COMPOSE_FILE }}"
          NGINX_FILE_PATH="${{ env.NGINX_FILE_PATH }}"
          DEPLOY_SCRIPT="${{ env.DEPLOY_SCRIPT }}"
          DOCKER_LOGIN_SCRIPT="${{ env.DOCKER_LOGIN_SCRIPT }}"
          GHCR_PAT_OR_TOKEN="${{ env.GHCR_PAT_OR_TOKEN }}"
          GHCR_REGISTRY="${{ env.GHCR_REGISTRY }}"
          GITHUB_ACTOR="${{ github.actor }}"

          ${{ env.SSH_CMD }} << EOF
            set -e 
            cd ~/${DEPLOY_DIR}
            
            # --- Login, Deploy, Logout ---
            chmod +x ./docker-login.sh
            ./docker-login.sh "${GHCR_PAT_OR_TOKEN}" "${GHCR_REGISTRY}" "${GITHUB_ACTOR}"
            
            echo "Running deployment script (deploy.sh)..."
            chmod +x ./deploy.sh
            ./deploy.sh

            echo "Logging out from GHCR..."
            docker logout ${GHCR_REGISTRY}
          EOF
